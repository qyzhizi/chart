<mxfile host="app.diagrams.net" modified="2023-07-13T21:45:22.913Z" agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36" etag="eM97Brk6F4ry05UYP8vJ" version="21.6.1" type="github">
  <diagram id="C5RBs43oDa-KdzZeNtuy" name="Page-1">
    <mxGraphModel dx="4174" dy="1840" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="3300" pageHeight="4681" background="none" math="0" shadow="0">
      <root>
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-0" />
        <mxCell id="WIyWlLk6GJQsqaUBKTNV-1" parent="WIyWlLk6GJQsqaUBKTNV-0" />
        <mxCell id="4rEQ4-RjstuRH-mUAFi--1" value="ImageProcessor" style="swimlane;fontStyle=2;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=26;horizontalStack=0;resizeParent=1;resizeLast=0;collapsible=1;marginBottom=0;rounded=0;shadow=0;strokeWidth=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="238" y="492" width="430" height="420" as="geometry">
            <mxRectangle x="230" y="140" width="160" height="26" as="alternateBounds" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--2" value="protected:&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="4rEQ4-RjstuRH-mUAFi--1" vertex="1">
          <mxGeometry y="26" width="430" height="26" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--3" value="    cv:Mat input_; " style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rounded=0;shadow=0;html=0;" parent="4rEQ4-RjstuRH-mUAFi--1" vertex="1">
          <mxGeometry y="52" width="430" height="26" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--4" value="    cvMat output_;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;rounded=0;shadow=0;html=0;" parent="4rEQ4-RjstuRH-mUAFi--1" vertex="1">
          <mxGeometry y="78" width="430" height="26" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--5" value="" style="line;html=1;strokeWidth=1;align=left;verticalAlign=middle;spacingTop=-1;spacingLeft=3;spacingRight=3;rotatable=0;labelPosition=right;points=[];portConstraint=eastwest;" parent="4rEQ4-RjstuRH-mUAFi--1" vertex="1">
          <mxGeometry y="104" width="430" height="8" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--18" value=" public:&#xa;  ImageProcessor() {}&#xa;  // Note that input matrices are assumed to be 8 bit 1 channel grayscale.&#xa;  virtual void LoadImage(cv::Mat &amp;input);&#xa;  // Gets the output image.&#xa;  virtual cv::Mat output();&#xa;  // For parallel implementations, this is a blocking call which finishes all&#xa;  // operations, acting as a barrier. This is useful for benchmarking&#xa;  // purposes, so that you can time a subset of an operation.&#xa;  // For serial versions, this will do nothing.&#xa;  virtual void FinishJobs() {}&#xa;  // Execute Gaussian Blur&#xa;  virtual void Gaussian() = 0;&#xa;  // Execute Sobel Filtering&#xa;  virtual void Sobel() = 0;&#xa;  // Execute Non-Maximum Supression&#xa;  virtual void NonMaxSuppression() = 0;&#xa;  // Execute Hysteresis Thresholding&#xa;  virtual void HysteresisThresholding() = 0;&#xa;  // Execute all stages as quickly as possible&#xa;  virtual void Canny();" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="4rEQ4-RjstuRH-mUAFi--1" vertex="1">
          <mxGeometry y="112" width="430" height="308" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--21" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0.498;entryY=1.003;entryDx=0;entryDy=0;entryPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--7" target="4rEQ4-RjstuRH-mUAFi--18" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="453.0000000000001" y="960" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-0" value="父类" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--21" vertex="1" connectable="0">
          <mxGeometry x="-0.1063" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--7" value="OpenclImageProcessor" style="swimlane;align=center;verticalAlign=top;childLayout=stackLayout;horizontal=1;startSize=26;horizontalStack=0;resizeParent=1;resizeLast=0;collapsible=1;marginBottom=0;rounded=0;shadow=0;strokeWidth=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="238" y="980" width="430" height="1050" as="geometry">
            <mxRectangle x="130" y="380" width="160" height="26" as="alternateBounds" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--8" value="  // OpenCL Objects&#xa;  std::vector&lt;cl::Platform&gt; platforms_;&#xa;  std::vector&lt;cl::Device&gt; devices_;&#xa;  cl::Device selected_device_;&#xa;  cl::Context context_;&#xa;  cl::CommandQueue queue_;&#xa;  // OpenCL kernels&#xa;  cl::Kernel gaussian_;&#xa;  cl::Kernel sobel_;&#xa;  cl::Kernel non_max_suppression_;&#xa;  cl::Kernel hysteresis_thresholding_;&#xa;  // Create a buffer to hold the direction angle theta&#xa;  cl::Buffer theta_;&#xa;  // Note that existing code assumes only two buffers exist&#xa;  cl::Buffer buffers_[2];&#xa;  // Keeps track of the next buffer to use as a destination. This should&#xa;  // not be accessed directly, instead look at using nextBuff/prevBuff.&#xa;  size_t buffer_index_ = 0;&#xa;  // Determines the NDRange workgroup size.&#xa;  int workgroup_size_ = 1;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fillColor=none;strokeColor=#005700;" parent="4rEQ4-RjstuRH-mUAFi--7" vertex="1">
          <mxGeometry y="26" width="430" height="294" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--15" value="" style="line;html=1;strokeWidth=1;align=left;verticalAlign=middle;spacingTop=-1;spacingLeft=3;spacingRight=3;rotatable=0;labelPosition=right;points=[];portConstraint=eastwest;" parent="4rEQ4-RjstuRH-mUAFi--7" vertex="1">
          <mxGeometry y="320" width="430" height="52" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--17" value="private:&#xa; // Private Methods&#xa;  // nextBuff returns a reference to the next buffer that should be modified.&#xa;  inline cl::Buffer&amp; NextBuff() { return buffers_[buffer_index_]; }&#xa;  // prevBuff returns a reference to the previous buffer that was modified.&#xa;  inline cl::Buffer&amp; PrevBuff() { return buffers_[buffer_index_ ^ 1]; }&#xa;  // Advance the buffer. Note there&#39;s only two, so right now it just swaps&#xa;  // to the other buffer.&#xa;  inline void AdvanceBuff() { buffer_index_ ^= 1; }&#xa;  // returns the &quot;desirable&quot; device. If a discrete GPU is detected, then it&#xa;  // will be preferred over integrated graphics. If devices is empty, then the&#xa;  // this will throw std::out_of_range.&#xa;  cl::Device&amp; GetBestDevice();&#xa;  // Return the relative path to the cpu or gpu  kernel given a filename&#xa;  // e.g. KernelPath(&quot;mykernel.cl&quot;, true); // returns: kernels/gpu/mykerne.cl&#xa;  std::string KernelPath(std::string filename, bool use_gpu);&#xa;  // Given a filename (without its path) load and return the kernel.&#xa;  cl::Kernel LoadKernel(std::string filename, std::string kernel_name,&#xa;                        bool use_gpu);" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fillColor=none;fontColor=#000000;strokeColor=#005700;labelBackgroundColor=none;" parent="4rEQ4-RjstuRH-mUAFi--7" vertex="1">
          <mxGeometry y="372" width="430" height="288" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--10" value="" style="line;html=1;strokeWidth=1;align=left;verticalAlign=middle;spacingTop=-1;spacingLeft=3;spacingRight=3;rotatable=0;labelPosition=right;points=[];portConstraint=eastwest;" parent="4rEQ4-RjstuRH-mUAFi--7" vertex="1">
          <mxGeometry y="660" width="430" height="52" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--20" value="public:&#xa;  // If use_gpu is true, this image processor will attempt to use the GPU&#xa;  OpenclImageProcessor(bool use_gpu = true);&#xa;  // outputs basic information about the device in use.&#xa;  void DeviceInfo();&#xa;  // Loads image. Note that input is assumed to be 8 bit 1 channel grayscale.&#xa;  void LoadImage(cv::Mat&amp; input);&#xa;  // Block until all other operations are complete and then return the cv::Mat&#xa;  // corresponding to the output of previously enqueued operations.&#xa;  cv::Mat output();&#xa;  // Blocking call which finishes all commands in queue. Useful for&#xa;  // benchmarking purposes, so that you can time a subset of an operation.&#xa;  void FinishJobs();&#xa;  // Enqueue the Gaussian blur operation. This is a non-blocking call.&#xa;  void Gaussian();&#xa;  // Enqueue the Sobel Filtering operation. This is a non-blocking call.&#xa;  void Sobel();&#xa;  // Enqueue the Non-maximum suppression operation. This is a non-blocking call.&#xa;  void NonMaxSuppression();&#xa;  // Enqueue the Hysteresis Thresholding operation. This is a non-blocking call.&#xa;  void HysteresisThresholding();&#xa;  // Enqueue all stages. This is a non-blocking call.&#xa;  void Canny();" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fillColor=none;fontColor=#000000;strokeColor=#005700;" parent="4rEQ4-RjstuRH-mUAFi--7" vertex="1">
          <mxGeometry y="712" width="430" height="338" as="geometry" />
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-6" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--29" target="4rEQ4-RjstuRH-mUAFi--31" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="1450" y="1580" />
              <mxPoint x="1450" y="1762" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-7" value="返回kernel路径信息 的函数" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="e9ibqu-G14n7SKy9qkeg-6" vertex="1" connectable="0">
          <mxGeometry x="0.6377" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-8" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--29" target="4rEQ4-RjstuRH-mUAFi--37" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="1330" y="1580" />
              <mxPoint x="1330" y="2117" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-9" value="加载 kernel 文件 的函数" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="e9ibqu-G14n7SKy9qkeg-8" vertex="1" connectable="0">
          <mxGeometry x="0.4391" y="4" relative="1" as="geometry">
            <mxPoint x="75" y="4" as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--29" value="private:&#xa;  // e.g. KernelPath(&quot;mykernel.cl&quot;, true); // returns: kernels/gpu/mykerne.cl&#xa;  std::string KernelPath(std::string filename, bool use_gpu);&#xa;  // Given a filename (without its path) load and return the kernel.&#xa;  cl::Kernel LoadKernel(std::string filename, std::string kernel_name,&#xa;                        bool use_gpu);" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="810" y="1530" width="430" height="100" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--30" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1.001;exitY=0.789;exitDx=0;exitDy=0;exitPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--17" target="4rEQ4-RjstuRH-mUAFi--29" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--83" value="加载kernel 文件" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--30" vertex="1" connectable="0">
          <mxGeometry x="-0.193" y="-1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--34" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--31" target="4rEQ4-RjstuRH-mUAFi--33" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2027" y="1942" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--31" value="private:&#xa;  // e.g. KernelPath(&quot;mykernel.cl&quot;, true); // returns: kernels/gpu/mykerne.cl&#xa;  std::string KernelPath(std::string filename, bool use_gpu);&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1665" y="1732" width="430" height="60" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--43" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.478;exitY=0.99;exitDx=0;exitDy=0;exitPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--33" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2622" y="1902" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--33" value="/***  Private Methods  ********************************************************/&#xa;// Return the relative path to the cpu or gpu  kernel given a filename&#xa;// e.g. KernelPath(&quot;mykernel.cl&quot;, true); // returns: kernels/gpu/mykerne.cl&#xa;&#xa;string OpenclImageProcessor::KernelPath(std::string filename, bool use_gpu) {&#xa;  // this is not platform independent and should be rewritten if that becomes&#xa;  // a requirement.&#xa;  string path = &quot;kernels/&quot;;&#xa;  if (use_gpu)&#xa;    path += &quot;gpu/&quot;;&#xa;  else&#xa;    path += &quot;cpu/&quot;;&#xa;  path += filename;&#xa;  return path;&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2417" y="1657" width="430" height="210" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--35" value="返回kernel路径信息" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2190" y="1722" width="130" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--37" value=" // Given a filename (without its path) load and return the kernel.&#xa;  cl::Kernel LoadKernel(std::string filename, std::string kernel_name,&#xa;                        bool use_gpu);" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1637" y="2087" width="430" height="60" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--39" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--37" target="4rEQ4-RjstuRH-mUAFi--40" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2027" y="2102" as="sourcePoint" />
            <Array as="points">
              <mxPoint x="2237" y="2117" />
              <mxPoint x="2237" y="2117" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--46" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--40" target="4rEQ4-RjstuRH-mUAFi--45" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--40" value="cl::Kernel OpenclImageProcessor::LoadKernel(string filename, string kernel_name,&#xa;        bool use_gpu) {&#xa;  ifstream cl_file(KernelPath(filename, use_gpu));&#xa;  if (!cl_file.good())&#xa;    cerr &lt;&lt; &quot;Couldn&#39;t open &quot; &lt;&lt; KernelPath(filename, use_gpu) &lt;&lt; endl;&#xa;  string cl_string(istreambuf_iterator&lt;char&gt;(cl_file),&#xa;                   (istreambuf_iterator&lt;char&gt;()));&#xa;  cl::Program::Sources source(&#xa;      1, make_pair(cl_string.c_str(), cl_string.length() + 1));&#xa;  cl::Program program(context_, source);&#xa;  try {&#xa;    program.build(devices_);&#xa;  } catch (cl::Error e) {&#xa;    // If there&#39;s a build error, print out the build log to see what&#xa;    // exactly the problem was.&#xa;    cerr &lt;&lt; &quot;Build Status:\t&quot;&#xa;         &lt;&lt; program.getBuildInfo&lt;CL_PROGRAM_BUILD_STATUS&gt;(selected_device_)&#xa;         &lt;&lt; endl &lt;&lt; &quot;Build Options:\t&quot;&#xa;         &lt;&lt; program.getBuildInfo&lt;CL_PROGRAM_BUILD_OPTIONS&gt;(selected_device_)&#xa;         &lt;&lt; endl &lt;&lt; &quot;Build Log:\t &quot;&#xa;         &lt;&lt; program.getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;(selected_device_) &lt;&lt; endl;&#xa;  }&#xa;  return cl::Kernel(program, kernel_name.c_str());" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2407" y="1912" width="430" height="360" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--41" value="加载kernel" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2210" y="2077" width="80" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--44" value="KernelPath" style="text;strokeColor=none;align=center;fillColor=none;html=1;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2627" y="1867" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--45" value="// ifstream 是 C++ 标准库中用于读取文件的输入流类，全称为 input file stream。它是 fstream 类的派生类，&#xa;// 用于从文件中读取数据。与 fstream 不同的是，ifstream 对象只能用于读取文件，而不能用于写入文件。&#xa;ifstream cl_file(KernelPath(filename, use_gpu));&#xa;&#xa;// 判断 ifstream 对象 是否能打开&#xa;cl_file.good()&#xa;&#xa;// 构造一个字符串对象，将文件全部内容转换为字符串。&#xa;// istreambuf_iterator&lt;char&gt;(cl_file) 是一个迭代器对象，&#xa;// 我们将这个迭代器对象作为 std::string 构造函数的第一个参数，表示读取的起始位置。&#xa;// std::string 构造函数的第二个参数使用了另一个 istreambuf_iterator&lt;char&gt; 类型的默认构造函数，&#xa;// 表示读取的终止位置，即读取整个输入流的内容。&#xa;&#xa;string cl_string(istreambuf_iterator&lt;char&gt;(cl_file),&#xa;                        (istreambuf_iterator&lt;char&gt;() ) );&#xa;&#xa;// 构造 kernel 程序 的源码对象&#xa;cl::Program::Sources source( 1, make_pair(cl_string.c_str(), cl_string.length() + 1));&#xa;&#xa;// 构造 kernel 程序 对象， context_ 是当前对象初始化时构造的上下文&#xa;cl::Program program(context_, source);&#xa;&#xa;// 这段代码使用了 OpenCL 编程框架来编译并构建一个程序对象 (cl::Program)，其中 context_ 是程序上下文对象，&#xa;// source 是程序源代码字符串，devices_ 是用于编译程序的设备列表。&#xa;// 首先，通过 cl::Program 类的构造函数创建一个程序对象 program，&#xa;// 并将上下文对象 context_ 和程序源代码字符串 source 作为参数传入。&#xa;// 这个构造函数会自动将源代码编译成针对给定设备的可执行代码。&#xa;// 接着，通过 program.build(devices_) 函数来编译并构建程序。&#xa;// devices_ 参数是一个 cl::vector 类型的设备列表，表示编译程序的目标设备。&#xa;// 编译完成后，可以向目标设备提交任务并执行程序。&#xa;// 需要注意的是，在编译程序时可能会出现错误，例如代码中使用了不支持的指令或语言特性等。&#xa;// 为了处理这些错误并进行调试，通常需要将 program.build 函数放在 try-catch 块中，以捕获任何可能的异常并进行相应的处理。 &#xa; &#xa;try { program.build(devices_);}&#xa;&#xa;&#xa;// 这段代码使用了 OpenCL 编程框架来创建一个内核对象 (cl::Kernel)，其中 program 是程序对象，kernel_name 是内核函数的名称。&#xa;// cl::Kernel 类的构造函数需要传入两个参数：程序对象 program 和内核函数的名称 kernel_name，&#xa;// 这样就可以根据给定的程序对象和内核函数名称创建一个内核对象。内核对象是一个执行单元，&#xa;// 可以在指定的设备上执行内核函数，从而完成特定的计算任务。&#xa;// 这段代码返回的是创建好的内核对象，可以在之后的程序中使用该对象来执行内核函数。&#xa;// 例如，可以通过调用 cl::CommandQueue 类中的 enqueueNDRangeKernel 函数来提交一个内核函数执行的命令，&#xa;// 从而在指定设备上执行内核函数。&#xa;&#xa;return cl::Kernel(program, kernel_name.c_str());&#xa;&#xa;&#xa;&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="3087" y="1757" width="720" height="670" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--47" value="LoadKernel 函数解释" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2857" y="2052" width="140" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--48" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" target="4rEQ4-RjstuRH-mUAFi--49" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2847" y="1717" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--49" value="// 存放 kernel 的文件路径，里面保存了各种 kernel ， 用于在GPU 的 kernel 执行。&#xa; string path = &quot;kernels/&quot;;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="3100" y="1690" width="610" height="55" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--50" value="KernelPath 函数解释" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2872" y="1677" width="130" height="30" as="geometry" />
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-3" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=-0.001;entryY=0.586;entryDx=0;entryDy=0;entryPerimeter=0;fontColor=#67de17;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--54" target="4rEQ4-RjstuRH-mUAFi--56" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--54" value="&#xa;  // Enqueue all stages. This is a non-blocking call.&#xa;  void Canny();" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontColor=#67de17;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="970" y="4465" width="300" height="68" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--55" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.539;exitY=1.008;exitDx=0;exitDy=0;exitPerimeter=0;entryX=-0.007;entryY=0.474;entryDx=0;entryDy=0;entryPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" target="4rEQ4-RjstuRH-mUAFi--54" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="461.94" y="1990.0339999999997" as="sourcePoint" />
            <mxPoint x="984.9999999999998" y="4504.3" as="targetPoint" />
            <Array as="points">
              <mxPoint x="463" y="1990" />
              <mxPoint x="463" y="4497" />
              <mxPoint x="950" y="4497" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--85" value="Canny 函数" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--55" vertex="1" connectable="0">
          <mxGeometry x="-0.9782" y="1" relative="1" as="geometry">
            <mxPoint y="75" as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-1" value="Canny 函数 ，主要的函数" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontColor=#67de17;" parent="4rEQ4-RjstuRH-mUAFi--55" vertex="1" connectable="0">
          <mxGeometry x="0.8548" y="-2" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-4" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;fontColor=#67de17;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--56" target="4rEQ4-RjstuRH-mUAFi--108" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-5" value="函数解释" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontColor=#67de17;" parent="e9ibqu-G14n7SKy9qkeg-4" vertex="1" connectable="0">
          <mxGeometry x="-0.2181" y="-2" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--56" value="// enqueues all of the canny stages&#xa;void OpenclImageProcessor::Canny() {&#xa;  Gaussian();&#xa;  Sobel();&#xa;  NonMaxSuppression();&#xa;  HysteresisThresholding();&#xa;}&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontColor=#67de17;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1420" y="4423" width="300" height="130" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--65" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--61" target="4rEQ4-RjstuRH-mUAFi--64" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--61" value="OpenclImageProcessor(bool use_gpu = true);" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1060" y="2519" width="300" height="34" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--62" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.999;exitY=0.079;exitDx=0;exitDy=0;exitPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--20" target="4rEQ4-RjstuRH-mUAFi--61" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="678" y="1719" as="sourcePoint" />
            <Array as="points">
              <mxPoint x="980" y="1719" />
              <mxPoint x="980" y="2530" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--63" value="构造函数" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="720" y="1680" width="70" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--68" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--64" target="4rEQ4-RjstuRH-mUAFi--67" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--104" value="解释构造函数" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--68" vertex="1" connectable="0">
          <mxGeometry x="-0.2207" y="-1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--64" value="// Perform all OpenCL setup steps required to have an operational image&#xa;// processor&#xa;OpenclImageProcessor::OpenclImageProcessor(bool use_gpu) {&#xa;  // Determine the NDRange size for each group. This should be made more&#xa;  // general in the future, but it works on most hardware for now.&#xa;  if (use_gpu)&#xa;    workgroup_size_ = 16;&#xa;  else&#xa;    workgroup_size_ = 1;&#xa;  // Initialize OpenCL&#xa;  try {&#xa;    cl::Platform::get(&amp;platforms_);&#xa;    if (use_gpu)&#xa;      platforms_[0].getDevices(CL_DEVICE_TYPE_GPU, &amp;devices_);&#xa;    else&#xa;      platforms_[0].getDevices(CL_DEVICE_TYPE_CPU, &amp;devices_);&#xa;    selected_device_ = GetBestDevice();&#xa;    context_ = cl::Context(devices_);&#xa;    queue_ = cl::CommandQueue(context_, selected_device_);&#xa;    // create and load the kernels&#xa;    gaussian_ = LoadKernel(&quot;gaussian_kernel.cl&quot;, &quot;gaussian_kernel&quot;, use_gpu);&#xa;    sobel_ = LoadKernel(&quot;sobel_kernel.cl&quot;, &quot;sobel_kernel&quot;, use_gpu);&#xa;    non_max_suppression_ =&#xa;           LoadKernel(&quot;non_max_supp_kernel.cl&quot;, &quot;non_max_supp_kernel&quot;, use_gpu);&#xa;    hysteresis_thresholding_ =&#xa;           LoadKernel(&quot;hyst_kernel.cl&quot;, &quot;hyst_kernel&quot;, use_gpu);&#xa;  } catch (cl::Error e) {&#xa;    cerr &lt;&lt; endl &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot; : &quot; &lt;&lt; e.err() &lt;&lt; endl;&#xa;  }&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1592" y="2312" width="468" height="448" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--66" value="构造函数" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1397" y="2541" width="70" height="30" as="geometry" />
        </mxCell>
        <mxCell id="HOKv8bW5_RLBBiIwSV7--1" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--67" target="HOKv8bW5_RLBBiIwSV7--0" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--67" value="// platforms_ 是 当前对象的变量，这里调用函数将平台信息保存到该变量中&#xa;// platforms_ 是 个容器对象： 原来定义：std::vector&lt;cl::Platform&gt; platforms_;&#xa;&#xa;cl::Platform::get(&amp;platforms_);&#xa;&#xa;// 使用cl::Platform 对象 获取gpu设备信息， 保存在 devices_ ， 它也是个容器&#xa;// std::vector&lt;cl::Device&gt; devices_;&#xa;&#xa;platforms_[0].getDevices(CL_DEVICE_TYPE_GPU, &amp;devices_);&#xa;&#xa;// 从devices_  返回一个最好的设备&#xa;selected_device_ = GetBestDevice();&#xa;&#xa;// 构建上下文对象， 创建命令队列（输入：context, selected_device_）&#xa;context_ = cl::Context(devices_);&#xa;queue_ = cl::CommandQueue(context_, selected_device_);&#xa;&#xa;// 加载 高斯 内核文件， 返回 内核对象 (cl::Kernel)&#xa;// create and load the kernels&#xa;gaussian_ = LoadKernel(&quot;gaussian_kernel.cl&quot;, &quot;gaussian_kernel&quot;, use_gpu);&#xa;&#xa;// 加载 sobel 内核文件， 返回 内核对象 (cl::Kernel)&#xa;sobel_ = LoadKernel(&quot;sobel_kernel.cl&quot;, &quot;sobel_kernel&quot;, use_gpu);&#xa;&#xa;后面的分别是 极大值抑制、滞后阈值的代码。&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;labelBorderColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2400" y="2350" width="423" height="372" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--75" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--70" target="4rEQ4-RjstuRH-mUAFi--74" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--70" value="cl::Device&amp; GetBestDevice();" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="780" y="1481" width="180" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--72" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--17" target="4rEQ4-RjstuRH-mUAFi--70" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--77" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--74" target="4rEQ4-RjstuRH-mUAFi--76" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--74" value="cl::Device&amp; GetBestDevice();" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1120" y="1481" width="180" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--81" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--76" target="4rEQ4-RjstuRH-mUAFi--80" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--76" value="// Returns (hopefully) the discrete GPU in devices. If none are found, then the&#xa;// first GPU is returned.&#xa;cl::Device &amp;OpenclImageProcessor::GetBestDevice() {&#xa;  if (devices_.size() == 0)&#xa;    throw std::out_of_range(&quot;No devices in devices vector.&quot;);&#xa;  // look for nvidia, amd, or ati. This may yield a false positive for&#xa;  // integrated amd GPUs, but it&#39;s better than the current solution.&#xa;  std::regex valid_device(&quot;(NVIDIA|AMD|ATI)&quot;, std::regex_constants::icase);&#xa;  for (auto &amp;d : devices_) {&#xa;    if (std::regex_search(d.getInfo&lt;CL_DEVICE_VENDOR&gt;(), valid_device))&#xa;      return d;&#xa;  }&#xa;  return devices_[0];&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1845" y="1456" width="460" height="210" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--78" value="获取最好的设备" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="670" y="1460" width="110" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--79" value="GetBestDevice()函数实现" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1657" y="1530" width="160" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--80" value="&#xa;// 这是 C++11 中的一种范围循环语法，也称为 for-each 循环。它用于遍历一个容器中的元素，每次循环将容器中的一个元素赋值给循环变量。&#xa;// 具体来说，在这段代码中，auto &amp;d 定义了一个循环变量 d，它的类型由编译器自动推导得出，可以理解为 devices_ 容器中存储的元素类型的引用。&#xa;// 后面的 devices_ 表示要遍历的容器，即设备列表。整个语法结构可以理解为“对于设备列表中的每一个设备（即容器中的每个元素），&#xa;// d将其引用赋值给变量 d，然后执行循环体”。&#xa;// 使用范围循环的好处是代码更加简洁，避免了手动维护循环变量的麻烦。同时，它也可以避免一些常见的错误，例如数组越界、迭代器失效等。&#xa;&#xa;for ( auto &amp;d : devices_)" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2490" y="1485.75" width="795" height="150.5" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--82" value="GetBestDevice()函数解释" style="text;html=1;align=center;verticalAlign=middle;resizable=0;points=[];autosize=1;strokeColor=none;fillColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2320" y="1530" width="160" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--86" value="void LoadImage(cv::Mat&amp; input);" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1040" y="3080" width="210" height="38" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--87" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--20" target="4rEQ4-RjstuRH-mUAFi--86" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="930" y="1861" />
              <mxPoint x="930" y="3100" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--89" value="加载图片，使用缓存" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--87" vertex="1" connectable="0">
          <mxGeometry x="-0.9337" y="2" relative="1" as="geometry">
            <mxPoint x="17" y="1" as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--93" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--90" target="4rEQ4-RjstuRH-mUAFi--92" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="2120" y="3081.9411764705883" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--94" value="LoadImage函数解释" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--93" vertex="1" connectable="0">
          <mxGeometry x="-0.1437" y="1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--90" value="void OpenclImageProcessor::LoadImage(cv::Mat &amp;image_input) {&#xa;  // We want the rows and columns to be an integer multiple of groupSize *after*&#xa;  // 2 is subtracted from them, since all of our kernels do not run edge&#xa;  // pixels. The following math yields the following results with groupSize=16&#xa;  // (using small integers for obviousness):&#xa;  // input size   desired size&#xa;  // 31           18&#xa;  // 32           18&#xa;  // 33           18&#xa;  // 34           34&#xa;  // 35           34&#xa;  int rows = ((image_input.rows - 2) / workgroup_size_) * workgroup_size_ + 2;&#xa;  int cols = ((image_input.cols - 2) / workgroup_size_) * workgroup_size_ + 2;&#xa;  // Use these new row/cols to create a rectangle which will serve as our crop&#xa;  cv::Rect croppedArea(0, 0, cols, rows);&#xa;  // Crop the image and clone it. If it&#39;s not cloned, then the layout of the&#xa;  // data won&#39;t change, so our kernels wouldn&#39;t be writing to the correct&#xa;  // location. This could be a place of likely inefficiency. It might be&#xa;  // better to move towards not actually cropping the image, instead doing&#xa;  // more work in the kernel.&#xa;  this-&gt;input_ = image_input(croppedArea).clone();&#xa;  output_ = cv::Mat(input_.rows, input_.cols, CV_8UC1);&#xa;    NextBuff() = cl::Buffer(&#xa;          context_, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR | CL_MEM_COPY_HOST_PTR,&#xa;      input_.rows * input_.cols * input_.elemSize(), input_.data);&#xa;    PrevBuff() = cl::Buffer(context_, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,&#xa;                          input_.rows * input_.cols * input_.elemSize());&#xa;  // Initialize the theta buffer&#xa;  theta_ = cl::Buffer(context_, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,&#xa;                     input_.rows * input_.cols * input_.elemSize());&#xa;    AdvanceBuff();&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1547" y="2875" width="520" height="470" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--91" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--86" target="4rEQ4-RjstuRH-mUAFi--90" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="1145" y="3110" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="HOKv8bW5_RLBBiIwSV7--3" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--92" target="HOKv8bW5_RLBBiIwSV7--2" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="HOKv8bW5_RLBBiIwSV7--4" value="总结" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="HOKv8bW5_RLBBiIwSV7--3" vertex="1" connectable="0">
          <mxGeometry x="0.1731" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--92" value="- #area/programming&#xa;#que OpenclImageProcessor::LoadImage(cv::Mat &amp;image_input) 的解释, 这个是canny opencl 实现的一部分&#xa;- #ans&#xa;```c++&#xa;//   for adaptation to workgroup_size_  , need cut origin image ，workgroup_size_ // is 16，that represent gpu workgroup size.&#xa;&#xa;int rows = ((image_input.rows - 2) / workgroup_size_) * workgroup_size_ + 2;&#xa;int cols = ((image_input.cols - 2) / workgroup_size_) * workgroup_size_ + 2;&#xa;&#xa;// create rect area in the origin image by new cols and new rows&#xa;cv::Rect croppedArea(0, 0, cols, rows);&#xa;&#xa;// clone origin image ,so the layout of data will chang, so the kernels will writing // to the correct location.&#xa;this-&gt;input_ = image_input(croppedArea).clone();&#xa;&#xa;// create mat object store  output&#xa;output_ = cv::Mat(input_.rows, input_.cols, CV_8UC1);&#xa;&#xa;// create Buffer object&#xa;NextBuff() = cl::Buffer(&#xa;      context_, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR | CL_MEM_COPY_HOST_PTR,&#xa;  input_.rows * input_.cols * input_.elemSize(), input_.data);&#xa;PrevBuff() = cl::Buffer(context_, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,&#xa;                      input_.rows * input_.cols * input_.elemSize());&#xa;&#xa;```&#xa;定义了两个`buffer`, 还定义了两个函数，其中NextBuff() 返回下标`buffer_index_`的缓存引用，PrevBuff()返回另外一个。&#xa;根据 OpenCL 1.2 规范，CL_MEM_ALLOC_HOST_PTR 标志指示 OpenCL 运行时系统为缓冲区分配主机可访问的内存空间，&#xa;并通过 clEnqueueMapBuffer 或 clEnqueueMapImage 等函数将缓冲区映射到主机内存空间中，以便主机程序可以直接访问缓冲区中的数据。&#xa;这种方法可以避免在主机和设备之间频繁地复制数据，从而提高数据传输的效率。&#xa;使用了 CL_MEM_ALLOC_HOST_PTR 标志，表明 OpenCL 运行时系统会为缓冲区分配主机可访问的内存空间，&#xa;并将缓冲区映射到主机内存空间中，以便主机程序直接访问缓冲区中的数据。在这种情况下，缓冲区的内存空间只在主机上分配了一次，&#xa;而在设备上并没有分配内存空间。当主机程序访问缓冲区时，OpenCL 运行时系统将负责将数据从主机内存传输到设备内存中，&#xa;以便设备程序可以访问数据。当设备程序访问缓冲区时，OpenCL 运行时系统将负责将数据从设备内存传输到主机内存中，&#xa;以便主机程序可以访问数据。&#xa;&#xa;`CL_MEM_READ_WRITE`: 分配的内存可以读可写&#xa;`CL_MEM_ALLOC_HOST_PTR`: 主机内存与设备内存都分配了空间&#xa;`CL_MEM_COPY_HOST_PTR`: 标志用于指定缓冲区对象初始化时从主机内存中拷贝数据到设备内存中。这意味着在创建缓冲区对象时，&#xa;OpenCL 运行时系统会将 `input_.data` 指向的数据从主机内存中拷贝到设备内存中的对应位置。&#xa;&#xa;&#xa;```c++&#xa;  // Initialize the theta buffer&#xa;  theta_ = cl::Buffer(context_, CL_MEM_READ_WRITE | CL_MEM_ALLOC_HOST_PTR,&#xa;                     input_.rows * input_.cols * input_.elemSize());&#xa;```&#xa;存放 梯度角度的缓存&#xa;&#xa;```c++&#xa;AdvanceBuff();&#xa;}&#xa;```&#xa;交换缓存，输入缓存、输出缓存交换位置。" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2290" y="2770" width="760" height="680" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--99" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--95" target="4rEQ4-RjstuRH-mUAFi--98" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--100" value="Gaussian 函数实现" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--99" vertex="1" connectable="0">
          <mxGeometry x="-0.2627" y="-1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--95" value="void LoadImage(cv::Mat&amp; input);" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="920" y="3837.25" width="210" height="38" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--96" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.707;exitDx=0;exitDy=0;exitPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--20" target="4rEQ4-RjstuRH-mUAFi--95" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="860" y="1930" />
              <mxPoint x="860" y="3860" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--97" value="Gaussian()" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--96" vertex="1" connectable="0">
          <mxGeometry x="-0.964" y="-2" relative="1" as="geometry">
            <mxPoint x="10" as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--102" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--98" target="4rEQ4-RjstuRH-mUAFi--101" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--103" value="Gaussian&amp;nbsp; 函数解释" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--102" vertex="1" connectable="0">
          <mxGeometry x="-0.2515" y="-1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--98" value="// enqueues the gaussian kernel&#xa;void OpenclImageProcessor::Gaussian() {&#xa;  try {&#xa;    gaussian_.setArg(0, PrevBuff());&#xa;    gaussian_.setArg(1, NextBuff());&#xa;    gaussian_.setArg(2, input_.rows);&#xa;    gaussian_.setArg(3, input_.cols);&#xa;    // 1,1 offset and -2 to to dimensions so that we don&#39;t run on edge pixels.&#xa;    queue_.enqueueNDRangeKernel(gaussian_, cl::NDRange(1, 1),&#xa;                                cl::NDRange(input_.rows - 2, input_.cols - 2),&#xa;                                cl::NDRange(workgroup_size_, workgroup_size_),&#xa;                                NULL);&#xa;  } catch (cl::Error e) {&#xa;    cerr &lt;&lt; endl &lt;&lt; &quot;Error: &quot; &lt;&lt; e.what() &lt;&lt; &quot; : &quot; &lt;&lt; e.err() &lt;&lt; endl;&#xa;  }&#xa;    AdvanceBuff();&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1330" y="3726.25" width="420" height="260" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--101" value="#area/programming&#xa;#que OpenclImageProcessor::Gaussian() 的解释, 这个是canny opencl 实现的一部分&#xa;#ans&#xa;&#xa;&#xa;```c++&#xa;gaussian_.setArg(0, PrevBuff());&#xa;gaussian_.setArg(1, NextBuff());&#xa;gaussian_.setArg(2, input_.rows);&#xa;gaussian_.setArg(3, input_.cols);&#xa;```&#xa;这个是为了给 `gaussian_` 设置参数。&#xa;这是`gaussian_` 内核对象对应的函数的签名, `__global` 表明该变量是全局变量(opencl 运行时中).&#xa;```c++&#xa;__kernel void gaussian_kernel(__global uchar *data,&#xa;                              __global uchar *out,&#xa;                                       size_t rows,&#xa;                                       size_t cols)&#xa;```&#xa;&#xa;&#xa;// queue_.enqueueNDRangeKernel 的函数原型是：&#xa;    cl_int enqueueNDRangeKernel(&#xa;        const Kernel&amp; kernel,&#xa;        const NDRange&amp; offset,&#xa;        const NDRange&amp; global,&#xa;        const NDRange&amp; local = NullRange,&#xa;        const VECTOR_CLASS&lt;Event&gt;* events = NULL,&#xa;        Event* event = NULL) const&#xa;&#xa;其中，kernel 参数表示要执行的 NDRange 内核函数对象，offset 参数表示每个维度上的偏移量，默认为原点，&#xa;global 参数表示每个维度上要处理的数据量，local 参数表示每个工作组中的工作项数量，默认为 NullRange，&#xa;表示使用默认局部工作大小。events 和 event 参数用于指定事件对象，用于异步执行内核函数和等待内核函数执行完成。&#xa;&#xa;//  cl::NDRange(1, 1) 表示 offset , 表示从原数据的（1,1）位置开始&#xa;//  cl::NDRange(input_.rows - 2, input_.cols - 2) 表示 global 的参数，表示要处理的全局数据量，通过offset 与 global 的参数&#xa;// 可以得到 要处理数据的 index.&#xa;//  表示工作组要处理的数据量，两个维度表示，workgroup_size_ 这里的值是 16&#xa;&#xa;&#xa;// 1,1 offset and -2 to to dimensions so that we don&#39;t run on edge pixels.&#xa;queue_.enqueueNDRangeKernel(gaussian_, cl::NDRange(1, 1),&#xa;                            cl::NDRange(input_.rows - 2, input_.cols - 2),&#xa;                            cl::NDRange(workgroup_size_, workgroup_size_),&#xa;                            NULL);&#xa;&#xa;&#xa;另外重要的：&#xa;&#xa;```c++&#xa;AdvanceBuff();&#xa;```&#xa;这个表示队列执行完内核对象的任务，切换buff, 输入变输出，输出变输入，这个函数在对象私有方法中。切换的目的是为了下一个&#xa;任务的输入其实是当前任务的输出，所以需要切换" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="3120" y="3468" width="720" height="776.5" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--108" value="先执行  Gaussian() 函数，这个是一个kernel  函数， 进行滤波。&#xa;它会在gpu 中执行。&#xa;然后 Sobel() 、NonMaxSuppression(); HysteresisThresholding();&#xa;都是一样在gpu 中执行。这些函数在类中都是Public 方法。&#xa;相关的函数解释看对应的函数。&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontColor=#67de17;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1817" y="4423" width="373" height="130" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--112" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--109" target="4rEQ4-RjstuRH-mUAFi--111" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--124" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=0.433;exitY=-0.012;exitDx=0;exitDy=0;exitPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--29" target="4rEQ4-RjstuRH-mUAFi--109" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="996" y="1100" />
              <mxPoint x="996" y="1100" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--125" value="内核函数的实现" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--124" vertex="1" connectable="0">
          <mxGeometry x="-0.6667" y="-1" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--109" value="内核函数源码" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="940" y="814.5" width="130" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--115" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--111" target="4rEQ4-RjstuRH-mUAFi--114" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--126" value="函数解释" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="4rEQ4-RjstuRH-mUAFi--115" vertex="1" connectable="0">
          <mxGeometry x="-0.8979" y="-2" relative="1" as="geometry">
            <mxPoint x="205" y="-11" as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--111" value="&#xa;&#xa;__constant float gaus[3][3] = { {0.0625, 0.125, 0.0625},&#xa;                                {0.1250, 0.250, 0.1250},&#xa;                                {0.0625, 0.125, 0.0625} };&#xa;&#xa;#define L_SIZE 16&#xa;&#xa;// Gaussian Kernel&#xa;// data: image input data with each pixel taking up 1 byte (8Bit 1Channel)&#xa;// out: image output data (8B1C)&#xa;__kernel void gaussian_kernel(__global uchar *data,&#xa;                              __global uchar *out,&#xa;                                       size_t rows,&#xa;                                       size_t cols)&#xa;{&#xa;    int sum = 0;&#xa;    size_t g_row = get_global_id(0);&#xa;    size_t g_col = get_global_id(1);&#xa;    size_t l_row = get_local_id(0) + 1;&#xa;    size_t l_col = get_local_id(1) + 1;&#xa;    &#xa;    size_t pos = g_row * cols + g_col;&#xa;    &#xa;    __local int l_data[L_SIZE+2][L_SIZE+2];&#xa;&#xa;    // copy to local&#xa;    l_data[l_row][l_col] = data[pos];&#xa;&#xa;    // top most row&#xa;    if (l_row == 1)&#xa;    {&#xa;        l_data[0][l_col] = data[pos-cols];&#xa;        // top left&#xa;        if (l_col == 1)&#xa;            l_data[0][0] = data[pos-cols-1];&#xa;&#xa;        // top right&#xa;        else if (l_col == L_SIZE)&#xa;            l_data[0][L_SIZE+1] = data[pos-cols+1];&#xa;    }&#xa;    // bottom most row&#xa;    else if (l_row == L_SIZE)&#xa;    {&#xa;        l_data[L_SIZE+1][l_col] = data[pos+cols];&#xa;        // bottom left&#xa;        if (l_col == 1)&#xa;            l_data[L_SIZE+1][0] = data[pos+cols-1];&#xa;&#xa;        // bottom right&#xa;        else if (l_col == L_SIZE)&#xa;            l_data[L_SIZE+1][L_SIZE+1] = data[pos+cols+1];&#xa;    }&#xa;&#xa;    if (l_col == 1)&#xa;        l_data[l_row][0] = data[pos-1];&#xa;    else if (l_col == L_SIZE)&#xa;        l_data[l_row][L_SIZE+1] = data[pos+1];&#xa;&#xa;    barrier(CLK_LOCAL_MEM_FENCE);&#xa;&#xa;    for (int i = 0; i &lt; 3; i++)&#xa;        for (int j = 0; j &lt; 3; j++)&#xa;            sum += gaus[i][j] * l_data[i+l_row-1][j+l_col-1];&#xa;&#xa;    out[pos] = min(255,max(0,sum));&#xa;&#xa;    return;&#xa;}&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1180" y="330" width="418" height="999" as="geometry" />
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-13" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--114" target="e9ibqu-G14n7SKy9qkeg-12" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-14" value="继续解释" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="e9ibqu-G14n7SKy9qkeg-13" vertex="1" connectable="0">
          <mxGeometry x="-0.3263" y="3" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--114" value="- #area/programming&#xa;#que opencl 内核函数高斯模糊源码解释&#xa;    - #ans&#xa;&#xa;```c++&#xa;__constant float gaus[3][3] = { {0.0625, 0.125, 0.0625},&#xa;                                {0.1250, 0.250, 0.1250},&#xa;                                {0.0625, 0.125, 0.0625} };&#xa;```&#xa;高斯卷积核&#xa;```c++&#xa;#define L_SIZE 16&#xa;```&#xa;每个工作组的工作项的边长，这里的工作项是：16*16&#xa;&#xa;&#xa;```c++&#xa;/ Gaussian Kernel&#xa;// data: image input data with each pixel taking up 1 byte (8Bit 1Channel)&#xa;// out: image output data (8B1C)&#xa;__kernel void gaussian_kernel(__global uchar *data,&#xa;                              __global uchar *out,&#xa;                                       size_t rows,&#xa;                                       size_t cols)&#xa;```&#xa;函数签名&#xa;&#xa;&#xa;```&#xa;{&#xa;    int sum = 0;&#xa;    // get current work global row in global data&#xa;    size_t g_row = get_global_id(0);&#xa;    // get current work global col in global data&#xa;    size_t g_col = get_global_id(1);&#xa;    // get &#xa;    size_t l_row = get_local_id(0) + 1;&#xa;    size_t l_col = get_local_id(1) + 1;&#xa;```&#xa;oepncl 这里把每个像素交給一个工作项处理，而每个工作项中可以调用函数获取当前工作项在全局数据中的位置。&#xa;`size_t g_row = get_global_id(0);` 获取当前工作在全局数据中的行, 0 代表第二个维度&#xa;`size_t g_col = get_global_id(1);` 获取当前工作在全局数据中的列, 1 代表第二个维度&#xa;&#xa;```c++&#xa;// get the postion of current work in the global data&#xa;size_t pos = g_row * cols + g_col;&#xa;&#xa;// the local array is created to store the data that is waiting for processing, it is shared among the current work group&#xa;__local int l_data[L_SIZE+2][L_SIZE+2];&#xa;```&#xa;获取当前工作项处理的数据在全局数据中的位置。&#xa;`l_data` 是当前工作组共享的数组 ， 是二维数组，边长是工作组的大小加2，加2 是为了考虑 padding ，因为处理工作组的边缘的工作项时，需要获取超出工作项范围数据。&#xa;&#xa;```c++&#xa;// copy to local&#xa;// copy the global data to the local array data; the copied data belongs to the current work item. &#xa;l_data[l_row][l_col] = data[pos];&#xa;```&#xa;注意每个工作项都会将自身对应的数据拷贝到当前工作组的数组，除了需啊padding的那一圈数据，由于padding 的数据与位于边缘的工作项有关，可以由下面的程序处理。&#xa;&#xa;&#xa;&#xa;&#xa;完整程序见：&#xa;https://github.com/smskelley/canny-opencl/blob/master/src/kernels/gpu/gaussian_kernel.cl" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;strokeWidth=4;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2130" y="314.5" width="930" height="1030" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--118" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--116" target="4rEQ4-RjstuRH-mUAFi--117" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--121" value="main&amp;nbsp; loop&amp;nbsp;" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="4rEQ4-RjstuRH-mUAFi--118" vertex="1" connectable="0">
          <mxGeometry x="0.8096" y="-3" relative="1" as="geometry">
            <mxPoint x="-138" y="-3" as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--116" value="main 主程序" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontSize=39;fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="4220" y="1832.5" width="330" height="65" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--120" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--117" target="4rEQ4-RjstuRH-mUAFi--119" edge="1">
          <mxGeometry relative="1" as="geometry">
            <Array as="points">
              <mxPoint x="5480" y="1865" />
              <mxPoint x="5480" y="1865" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--122" value="流程解释" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="4rEQ4-RjstuRH-mUAFi--120" vertex="1" connectable="0">
          <mxGeometry x="-0.246" y="3" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--117" value="// This application runs the desired canny algorithm on webcam data,&#xa;// displaying it back to the user in near real time.&#xa;#include &lt;iostream&gt;&#xa;#include &lt;opencv2/highgui/highgui.hpp&gt;&#xa;#include &quot;autotimer.h&quot;&#xa;#include &quot;imageprocessor.h&quot;&#xa;#include &quot;openclimageprocessor.h&quot;&#xa;#include &quot;serialimageprocessor.h&quot;&#xa;using namespace std;&#xa;using namespace ImageProcessors;&#xa;using Benchmarking::AutoTimer;&#xa;// Called when timer finishes, output the amount of time it took.&#xa;void onTimerFinish(double time) {&#xa;  cout &lt;&lt; &quot;Took &quot; &lt;&lt; time &lt;&lt; &quot; milliseconds.\n&quot;;&#xa;}&#xa;int main(int argc, char *argv[]) {&#xa;  cv::VideoCapture webcam(0);&#xa;  cv::Mat in_frame, gray_frame;&#xa;  bool use_gpu = true;&#xa;  bool use_parallel = true;&#xa;  unique_ptr&lt;ImageProcessor&gt; processor(nullptr);&#xa;  // parse command line arguments&#xa;  for (int i = 1; i &lt; argc; i++) {&#xa;    if (strcmp(argv[i], &quot;cpu&quot;) == 0)&#xa;      use_gpu = false;&#xa;    else if (strcmp(argv[i], &quot;serial&quot;) == 0)&#xa;      use_parallel = false;&#xa;  }&#xa;  // Create and load the appropriate image processor&#xa;  if (use_parallel)&#xa;    processor.reset(new OpenclImageProcessor(use_gpu));&#xa;  else&#xa;    processor.reset(new SerialImageProcessor());&#xa;  // grab new frame, convert to grayscale, detect edges, then display the result.&#xa;  while (true) {&#xa;    webcam.read(in_frame);&#xa;    cv::cvtColor(in_frame, gray_frame, cv::COLOR_BGR2GRAY);&#xa;    processor-&gt;LoadImage(gray_frame);&#xa;    processor-&gt;FinishJobs();&#xa;    {&#xa;      AutoTimer timer(onTimerFinish);&#xa;      processor-&gt;Canny();&#xa;      processor-&gt;FinishJobs();&#xa;    }&#xa;    imshow(&quot;canny&quot;, processor-&gt;output());&#xa;    if (cv::waitKey(30) &gt;= 0) break;&#xa;  }&#xa;  return 0;&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="4890" y="1510" width="470" height="710" as="geometry" />
        </mxCell>
        <mxCell id="4rEQ4-RjstuRH-mUAFi--119" value="#que canny algorithm implementing by opencl 主函数流程&#xa;#ans&#xa;github 地址：https://github.com/smskelley/canny-opencl/&#xa;&#xa;主要的程序：&#xa;https://github.com/smskelley/canny-opencl/blob/master/src/live-capture/live-capture.cpp&#xa;&#xa;&#xa;在下面程序有个关键：new OpenclImageProcessor(use_gpu)  ，OpenclImageProcessor 是这个程序的主要的类&#xa;```c++&#xa;&#xa;// Create and load the appropriate image processor&#xa;if (use_parallel)&#xa;  // create OpenclImageProcessor object &#xa;  processor.reset(new OpenclImageProcessor(use_gpu));&#xa;else&#xa;  processor.reset(new SerialImageProcessor());&#xa;&#xa;// grab new frame, convert to grayscale, detect edges, then display the result.&#xa;while (true) {&#xa;  // read a image form camera&#xa;  webcam.read(in_frame);&#xa;  cv::cvtColor(in_frame, gray_frame, cv::COLOR_BGR2GRAY);&#xa;  // loder image , create buffers &#xa;  processor-&gt;LoadImage(gray_frame);&#xa;&#xa;  processor-&gt;FinishJobs();&#xa;  {&#xa;    AutoTimer timer(onTimerFinish);&#xa;    // run canny algorithm in CPU or GPU&#xa;    processor-&gt;Canny();&#xa;    // Block until all jobs finish&#xa;    processor-&gt;FinishJobs();&#xa;  }&#xa;&#xa;  imshow(&quot;canny&quot;, processor-&gt;output());&#xa;  if (cv::waitKey(30) &gt;= 0) break;&#xa;}&#xa;```&#xa;&#xa;&#xa;#que c++ AutoTimer 类型的对象 计时&#xa;    - #ans&#xa;&#xa;```c++&#xa;// Called when timer finishes, output the amount of time it took.&#xa;void onTimerFinish(double time) {&#xa;  cout &lt;&lt; &quot;Took &quot; &lt;&lt; time &lt;&lt; &quot; milliseconds.\n&quot;;&#xa;}&#xa;{&#xa; AutoTimer timer(onTimerFinish);&#xa; processor-&gt;Canny();&#xa; processor-&gt;FinishJobs();&#xa;}&#xa;```&#xa;这段代码似乎定义了一个函数 onTimerFinish，它接受一个 double 类型的参数 time，并使用 cout 输出一个包含毫秒时间的消息到控制台。&#xa;&#xa;代码还创建了一个 AutoTimer 类型的对象，并将 onTimerFinish 作为参数传递给它的构造函数。AutoTimer 对象可能在构造时启动计时器，&#xa;并在被销毁时停止计时器（例如，当它超出作用域时）。接着在 AutoTimer 对象的作用域内调用了 processor-&gt;Canny() 和 processor-&gt;FinishJobs() 函数。&#xa;这可能意味着计时器正在测量这些函数执行所需的时间。" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;fontColor=#000000;labelBackgroundColor=#E3E3E3;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="5520" y="1440" width="840" height="870" as="geometry" />
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-9" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="K721ay5TRWsDCcdxaadF-4" target="K721ay5TRWsDCcdxaadF-8" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="1130" y="4178" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-4" value="cv::Mat output();" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="930" y="4160" width="110" height="38" as="geometry" />
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-6" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;entryX=0;entryY=0.5;entryDx=0;entryDy=0;exitX=0.999;exitY=0.81;exitDx=0;exitDy=0;exitPerimeter=0;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="4rEQ4-RjstuRH-mUAFi--20" target="K721ay5TRWsDCcdxaadF-4" edge="1">
          <mxGeometry relative="1" as="geometry">
            <mxPoint x="930" y="3929" as="targetPoint" />
            <mxPoint x="750" y="1960" as="sourcePoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-7" value="output()&amp;nbsp;" style="edgeLabel;html=1;align=center;verticalAlign=middle;resizable=0;points=[];" parent="K721ay5TRWsDCcdxaadF-6" vertex="1" connectable="0">
          <mxGeometry x="-0.9493" y="-4" relative="1" as="geometry">
            <mxPoint as="offset" />
          </mxGeometry>
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-11" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="K721ay5TRWsDCcdxaadF-8" target="K721ay5TRWsDCcdxaadF-10" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-8" value="cv::Mat output()  函数实现" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1230" y="4160" width="170" height="38" as="geometry" />
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-13" value="" style="edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;" parent="WIyWlLk6GJQsqaUBKTNV-1" source="K721ay5TRWsDCcdxaadF-10" target="K721ay5TRWsDCcdxaadF-12" edge="1">
          <mxGeometry relative="1" as="geometry" />
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-10" value="// copies the buffer back from the device and returns it. This will block.&#xa;cv::Mat OpenclImageProcessor::output() {&#xa;  // copy the buffer back&#xa;  queue_.enqueueReadBuffer(PrevBuff(), CL_TRUE, 0,&#xa;                          input_.rows * input_.cols * input_.elemSize(),&#xa;                          output_.data);&#xa;  queue_.finish();&#xa;  assert(output_.rows == input_.rows &amp;&amp; output_.cols == input_.cols);&#xa;  return output_;&#xa;}" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="1665" y="4099" width="500" height="160" as="geometry" />
        </mxCell>
        <mxCell id="K721ay5TRWsDCcdxaadF-12" value="output_ 是类在LoadImage 函数 中 定义的Mat 类型的对象" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2190" y="4099" width="500" height="160" as="geometry" />
        </mxCell>
        <mxCell id="e9ibqu-G14n7SKy9qkeg-12" value="接下来这段程序就是处理，边缘工作项的情况，把当前工作项旁边的数据从global 数据区拷贝过来。&#xa;如图所示：&#xa;![](https://qyzhizi.cn/img/202307061913051.png)&#xa;```c++&#xa;// top most row&#xa;if (l_row == 1)&#xa;{&#xa;l_data[0][l_col] = data[pos-cols];&#xa;// top left&#xa;if (l_col == 1)&#xa;l_data[0][0] = data[pos-cols-1];&#xa;&#xa;// top right&#xa;else if (l_col == L_SIZE)&#xa;l_data[0][L_SIZE+1] = data[pos-cols+1];&#xa;}&#xa;// bottom most row&#xa;else if (l_row == L_SIZE)&#xa;{&#xa;l_data[L_SIZE+1][l_col] = data[pos+cols];&#xa;// bottom left&#xa;if (l_col == 1)&#xa;l_data[L_SIZE+1][0] = data[pos+cols-1];&#xa;&#xa;// bottom right&#xa;else if (l_col == L_SIZE)&#xa;l_data[L_SIZE+1][L_SIZE+1] = data[pos+cols+1];&#xa;}&#xa;&#xa;if (l_col == 1)&#xa;l_data[l_row][0] = data[pos-1];&#xa;else if (l_col == L_SIZE)&#xa;l_data[l_row][L_SIZE+1] = data[pos+1];&#xa;```&#xa;&#xa;```c++&#xa;// wait until all above work items have already finished.&#xa;barrier(CLK_LOCAL_MEM_FENCE);&#xa;```&#xa;这是为了等待所有工作项都完成上面的工作，这是为保证，后续工作项运算时，确保旁边8个位置的数据已经就绪了。&#xa;&#xa;&#xa;&#xa;以下程序是正式利用高斯算子，进行高斯模糊化计算。&#xa;![](https://qyzhizi.cn/img/202307061930917.png)&#xa;```c++&#xa;// gaus calculation&#xa;for (int i = 0; i &lt; 3; i++)&#xa;for (int j = 0; j &lt; 3; j++)&#xa;sum += gaus[i][j] * l_data[i+l_row-1][j+l_col-1];&#xa;&#xa;out[pos] = min(255,max(0,sum));&#xa;&#xa;return;&#xa;```" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;strokeWidth=4;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="3410" y="409.5" width="670" height="840" as="geometry" />
        </mxCell>
        <mxCell id="HOKv8bW5_RLBBiIwSV7--0" value="总结：&#xa;- 获取设备信息&#xa;- 使用设备信息，创建命令队列，用于提交内核对象到设备执行&#xa;- 生成内核对象（高斯滤波、sobel、极大值抑制、滞后阈值）" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;labelBorderColor=none;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="2910" y="2500" width="423" height="72" as="geometry" />
        </mxCell>
        <mxCell id="HOKv8bW5_RLBBiIwSV7--2" value="总结：&#xa;- 裁剪图片，保证图片可以划分为工作组的整数倍&#xa;- 将裁剪后的图片拷贝一份，保存到input_， 这样可以保证工作组索引不会引用错误的像素。&#xa;- 创建两个缓存，该缓存的生命周期由opencl 的运行时管理，不用担心内存回收的问题&#xa;- 这两个缓存是个循环缓存，分别代表kernel 对象的输入与输出，后续还有几个kernel 对象需要执行，它们是串&#xa;连的，将这个两个缓存的的名称转换，原来的输出变为输入，原来的输入将保存当前 kernel 的输出。最开始的输入就是&#xa;原始裁剪后的图片。&#xa;- 这里两个缓存是沟通主机内存与设备显存的桥梁，它们有opencl 运行时实现，缓存可以实现在主机申请内存，&#xa;但设备需要数据时，自动把数据传输到设备。同样可以把设备的线显存的数据输出到主机内存。&#xa;" style="text;align=left;verticalAlign=top;spacingLeft=4;spacingRight=4;overflow=hidden;rotatable=0;points=[[0,0.5],[1,0.5]];portConstraint=eastwest;" parent="WIyWlLk6GJQsqaUBKTNV-1" vertex="1">
          <mxGeometry x="3210" y="3030" width="655" height="160" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>
